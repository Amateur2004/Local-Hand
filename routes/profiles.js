const express = require('express');
const router = express.Router();
const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});

router.get('/categories', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM categories');
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching categories:', err);
    res.status(500).json({ error: 'Failed to fetch categories' });
  }
});

router.get('/subcategories/:category', async (req, res) => {
  try {
    const categoryName = req.params.category;
    const categoryResult = await pool.query(
      'SELECT category_id FROM categories WHERE category_name = $1',
      [categoryName]
    );
    if (categoryResult.rows.length === 0) {
      return res.status(404).json({ error: 'Category not found' });
    }
    const categoryId = categoryResult.rows[0].category_id;
    const result = await pool.query(
      'SELECT * FROM sub_categories WHERE category_id = $1',
      [categoryId]
    );
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching subcategories:', err);
    res.status(500).json({ error: 'Failed to fetch subcategories' });
  }
});

router.get('/tags', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM tags');
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching tags:', err);
    res.status(500).json({ error: 'Failed to fetch tags' });
  }
});

router.post('/create-service-provider', (req, res, next) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  next();
}, async (req, res) => {
  const { category, name, phone_no, address, description, bank_name, ifsc, acc_no, sub_categories, tags } = req.body;
  const gmail = req.user.gmail;

  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Validate category and get category_id
    const categoryResult = await client.query('SELECT category_id FROM categories WHERE category_name = $1', [category]);
    if (categoryResult.rows.length === 0) {
      throw new Error('Invalid category');
    }
    const category_id = categoryResult.rows[0].category_id;

    // Check if the user already has a profile for this category (profile_type)
    const existingProfile = await client.query(
      'SELECT profile_id FROM accounts WHERE gmail = $1 AND profile_type = $2',
      [gmail, category]
    );

    if (existingProfile.rows.length > 0) {
      throw new Error(`You already have a ${category} profile. Multiple profiles for the same category are not allowed.`);
    }

    // Check if the user has any existing profile (to get spid)
    const existingAccount = await client.query(
      'SELECT profile_id, spid FROM accounts a JOIN service_provider sp ON a.profile_id = sp.spsid WHERE a.gmail = $1 LIMIT 1',
      [gmail]
    );

    let spid;
    if (existingAccount.rows.length > 0) {
      // Gmail exists, reuse the existing spid
      spid = existingAccount.rows[0].spid;
    } else {
      // Gmail does not exist, generate a new spid
      spid = `spid_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
    }

    // Insert into service_provider (spsid is auto-generated by SERIAL)
    const spResult = await client.query(
      'INSERT INTO service_provider (spid, category_id, name, phone_no, address, description, bank_name, ifsc, acc_no, tags, status) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING spsid',
      [spid, category_id, name, phone_no, address, description || '', bank_name, ifsc, acc_no, tags || [], 'Not Verified']
    );
    const spsid = spResult.rows[0].spsid;
    console.log('Inserted service provider:', { spsid, spid });

    // Insert into accounts
    await client.query(
      'INSERT INTO accounts (gmail, profile_type, profile_id) VALUES ($1, $2, $3)',
      [gmail, category, spsid]
    );
    console.log('Inserted into accounts:', { gmail, profile_type: category, profile_id: spsid });

    // Insert subcategories
    for (const sub of sub_categories) {
      const subCatResult = await client.query(
        'SELECT sub_category_id FROM sub_categories WHERE sub_category_id = $1 AND category_id = $2',
        [sub.sub_category_id, category_id]
      );
      if (subCatResult.rows.length === 0) {
        throw new Error(`Invalid sub-category ${sub.sub_category_id} for category ${category}`);
      }
      await client.query(
        'INSERT INTO sub_category_to_service_provider (sub_category_id, spsid, min_cost) VALUES ($1, $2, $3)',
        [sub.sub_category_id, spsid, sub.min_cost]
      );
      console.log('Inserted sub_category_to_service_provider:', { sub_category_id: sub.sub_category_id, spsid, min_cost: sub.min_cost });
    }

    /* Insert tags
    for (const tagId of tags.slice(0, 5)) {
      const tagResult = await client.query('SELECT tag_id FROM tags WHERE tag_id = $1', [tagId]);
      if (tagResult.rows.length === 0) {
        throw new Error(`Invalid tag ID: ${tagId}`);
      }
      await client.query(
        'INSERT INTO service_provider (spsid, tag_id) VALUES ($1, $2) ON CONFLICT DO NOTHING',
        [spsid, tagId]
      );
      console.log('Inserted service_provider_tags:', { spsid, tag_id: tagId });
    }*/

    // Insert into to_be_verified_profiles
    await client.query(
      'INSERT INTO to_be_verified_profiles (spsid, status) VALUES ($1, $2)',
      [spsid, 'Pending']
    );
    console.log('Inserted into to_be_verified_profiles:', { spsid, status: 'Pending' });

    await client.query('COMMIT');
    res.json({ message: 'Service provider profile created and sent for verification' });
  } catch (err) {
    await client.query('ROLLBACK');
    console.error('Error creating service provider profile:', err.message);
    res.status(500).json({ error: err.message || 'Failed to create service provider profile' });
  } finally {
    client.release();
  }
});

module.exports = router;